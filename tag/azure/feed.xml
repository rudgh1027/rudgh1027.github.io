<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="/tag/azure/feed.xml" rel="self" type="application/atom+xml" />
  <link href="/" rel="alternate" type="text/html" />
  <updated>2019-12-16T10:57:47+09:00</updated>
  <id>/tag/azure/feed.xml</id>

  
  
  

  
    <title type="html">GKArchy | </title>
  

  
    <subtitle>IT Service Technology Blog</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">CICD pipeline for container based workloads</title>
      <link href="/CICD-pipeline-for-container-based-workloads" rel="alternate" type="text/html" title="CICD pipeline for container based workloads" />
      <published>2019-11-12T19:18:00+09:00</published>
      <updated>2019-11-12T19:18:00+09:00</updated>
      <id>/CICD-pipeline-for-container-based-workloads</id>
      <content type="html" xml:base="/CICD-pipeline-for-container-based-workloads">&lt;h2 id=&quot;describe-this-pattern-1&quot;&gt;Describe this pattern &lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;https://docs.microsoft.com/en-us/azure/architecture/example-scenario/apps/media/architecture-devops-with-aks.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;feature&quot;&gt;Feature&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;In order to know details about this architecture, click above URL.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;implement&quot;&gt;Implement&lt;/h2&gt;
&lt;h3 id=&quot;1-make-resource-from-predefined-template&quot;&gt;1. Make resource from predefined template.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Right click the Link: &lt;a href=&quot;https://portal.azure.com/#create/Microsoft.Template/uri/https%3A%2F%2Fraw.githubusercontent.com%2Fmspnp%2Fsolution-architectures%2Fmaster%2Fapps%2Fdevops-with-aks%2Fazuredeploy.json&quot;&gt;Click Here&lt;/a&gt;, and open in the new tab.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Login to Azure, then you can see &lt;b&gt;Custom deployment&lt;/b&gt; in azure portal.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Click azure cloud shell button on the top of the web page.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;After loading Azure Cloud Shell, Type &lt;code&gt;az ad sp create-for-rbac --name myDevOpsScenario&lt;/code&gt;
&lt;br /&gt; ※ If it says you don’t have sufficiant privilige, ask your owner of subscription to give you &lt;b&gt;Owner&lt;/b&gt; role or custom role that has &lt;b&gt;Microsoft.Authorization/roleAssignments/write&lt;/b&gt;. Every predefined role don’t have that permition. &lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn2&quot; id=&quot;fnref2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;
&lt;img src=&quot;/assets/images/001.spinfo.png&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Make SSH Key : Type &lt;code&gt;ssh-keygen -t rsa -b 2048&lt;/code&gt; on your cloud shell. Terminal may ask you key name and passphrase. Just type &lt;b&gt;Enter&lt;/b&gt; key.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Find the supported Kubernetes versions for your deployment region : &lt;code&gt;az aks get-versions -l &lt;region&gt; --query &quot;orchestrators[?default!=null].orchestratorVersion&quot; -o tsv&amp;lt;/code&amp;gt;&lt;/region&gt;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;From now, you can fill on the blanks.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/001.deploymain.png&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Sp Clint Id : “appId” of previous step&lt;/li&gt;
  &lt;li&gt;Sp Clint Secret : ““password” of previous step&lt;/li&gt;
  &lt;li&gt;Linux Admin Username &amp;amp; Password : Now, you should define.&lt;/li&gt;
  &lt;li&gt;Linux SSH Public Key : We already make it in previous step. Type the command on cloud shell &lt;code&gt;cat ~/.ssh/id_rsa.pub&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Kubernetes Version : Type as you know.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Waiting for 20-30 minute.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-enter-jenkins-web-page&quot;&gt;2. Enter Jenkins Web Page.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Click Jenkins server on your resource tab in azure portal. And copy public IP Address of jenkins server.&lt;/li&gt;
  &lt;li&gt;Type http://(public ip address) on your browser. Than you can see the page like below.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/001.jenkins_default.png&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;You need to use ssh cli command. When you use linux or MAC environment, you just type command &lt;code&gt;ssh -L 127.0.0.1:8080:localhost:8080 (your username)@jenkinsg.......&lt;/code&gt; sign in your browser. If you use windows environment, you need to install 3th-party ssh tool.&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;In the lab, I’m going to use git bash to establish ssh connection.
Open git bash terminal - type &lt;code&gt;ssh -L 127.0.0.1:8080:localhost:8080 (your username)@jenkinsg.......&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;Now you can connect web console page through forwarded local port. Type http://localhost:8080 on your browser.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/unlock_jenkins.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Then, you will see below page. To unlock jenkins server, Connect to jenkins server on azure cloud shell. &lt;code&gt;ssh (yourID)@(Jenkins Public IP)&lt;/code&gt;. Because you generate ssh key in yuor cloud shell environment, you don’t have to type your password. In order to get password for unlocking jenkins web console, type &lt;code&gt;sudo cat /var/lib/jenkins/secrets/initialAdminPassword&lt;/code&gt; &lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn3&quot; id=&quot;fnref3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;Create initial admin account and Install suggested plugins. Now, you can see Jenkins Dashboard.&lt;/li&gt;
  &lt;li&gt;In main page of jenkins console, click &lt;b&gt;Hello World Build &amp;amp; Deploy&lt;/b&gt; link. Then you can see deployed pipeline.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/001.jenkins_pipeline.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-enter-grafana-web-page&quot;&gt;3. Enter Grafana Web Page.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Reset admin password
    &lt;ul&gt;
      &lt;li&gt;Check public IP address of Grafana VM. Type &lt;code&gt;ssh (your admin ID)@(Grafana Public IP)&lt;/code&gt; on your cloud shell.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
    sudo -s
    apt install sqlite3
    sqlite3 /var/lib/grafana/grafana.db
    update user set password = '59acf18b94d7eb0694c61e60ce44c110c7a683ac6a8f09580d626f90f4a242000746579358d77dd9e570e83fa24faa88a8a6', salt = 'F3FAxVm33R' where login = 'admin'
    
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;Enter Web page on your browser : http://(Grafana Public IP):3000&lt;/li&gt;
  &lt;li&gt;Login : admin / admin ( Initialized in step “Reset admin password” )&lt;/li&gt;
  &lt;li&gt;Now, we can connect to Grafana web page. Data source from azure monitor is already prepared for you.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/001.grafana_main.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If you want to add Data source&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/001.add_datasource.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;-To fill in the blacks, type “ac account list” on your azure cloud shell.&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;You can make dashboard  like below image.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/001.grafana_makedashboard.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4-make-container-image-in-acr&quot;&gt;4. Make container image in ACR&lt;/h3&gt;

&lt;h4 id=&quot;1-make-development-environment&quot;&gt;1) Make development environment&lt;/h4&gt;
&lt;p&gt;Before login to ACR (Azure Container Registry), you’re supposed to have environment that has docker engine and az cli package.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Deploy ubuntu server with docker engine in azure.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
##############
## RG CREATE ##
##############
loc=                ##### INSERT YOUR VALUE!!!!
rgname=             ##### INSERT YOUR VALUE!!!!

az group create --location $loc --name $rgname

##############
## VM CREATE ##
##############

adminname=          ##### INSERT YOUR VALUE!!!!
vmname=             ##### INSERT YOUR VALUE!!!!

az vm create \
  --resource-group $rgname \
  --name $vmname \
  --image UbuntuLTS \
  --admin-username $adminname 

####################
## DOCKER EXTENSION ##
####################

az vm extension set --name DockerExtension --publisher Microsoft.Azure.Extensions --resource-group $rgname --vm-name $vmname


###################
## CONNECT TO VM ##
###################

pip=$(az vm list-ip-addresses --name $vmname | jq &quot;.[].virtualMachine.network.publicIpAddresses[0].ipAddress&quot; -r)
ssh $adminname@$pip

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Install az cli to ubuntu server&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
sudo -s
curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Install jq library to ubuntu server in order to use az cli esaily&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
apt install jq -y

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;2-login-to-az-cli-with-sp&quot;&gt;2) Login to az cli with SP&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;
az login --service-principal -u http://((SP name)) --tenant ((your tenant name))
##input SP password

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;3-login-to-acr&quot;&gt;3) Login to ACR&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;
acrname=$(az acr list --resource-group ((your RG name)) | jq -r &quot;.[].name&quot;)
az acr login --name $acrname
##Login Succeeded

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;4-make-docker-web-application&quot;&gt;4) Make docker web application&lt;/h4&gt;
&lt;p&gt;In this step, I’ll use ASP.NET MVC WEB image.
Look at the post &lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn4&quot; id=&quot;fnref4&quot;&gt;[4]&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h4 id=&quot;5-push-to-the-acr-5&quot;&gt;5) Push to the ACR &lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn5&quot; id=&quot;fnref5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt;&lt;/h4&gt;
&lt;p&gt;After done precess that written in the above post&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
loginsvr=$(az acr list --resource-group ((your resource group name)) | jq -r &quot;.[].loginServer&quot;)
docker tag test $loginsvr/azure-asp-net-web:v1
docker images

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then you can see the redefined image with tag “v1”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
docker push $loginsvr/azure-asp-net-web:v1
az acr repository list --name $acrname --output table

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;5-deploy-container-to-aks-6&quot;&gt;5. Deploy container to AKS &lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn6&quot; id=&quot;fnref6&quot;&gt;[6]&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;
&lt;h4 id=&quot;1-install-the-kubernetes-cli&quot;&gt;1) Install the kubernetes cli&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;
az aks install-cli

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;2-install-the-kubernetes-cli-7&quot;&gt;2) Install the kubernetes cli &lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn7&quot; id=&quot;fnref7&quot;&gt;[7]&lt;/a&gt;&lt;/sup&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;
aksname=$(az aks list | jq -r &quot;.[].name&quot;)
az aks get-credentials  --resource-group ((your resource group name)) --name $aksname
### It will reply that &quot;Merged ((your aks name)) as current context in /home/((your admin id))/.kube/config&quot;

kubectl get nodes

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3-make-deployment-yaml-file&quot;&gt;3) Make deployment yaml file&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
## vi ~/test/azure-asp-net-web.yaml

apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: azure-asp-net-web
spec:
  replicas: 2
  template:
    metadata:
      labels:
        app: azure-asp-net-web
    spec:
      containers:
        - name: azure-asp-net-web
          image: acrfbfxvhmzjaele.azurecr.io/azure-asp-net-web:v1  ## replce with your ACR name
          ports:
            - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
    name: azure-asp-net-lb
spec:
  ports:
    - name: http-port
      port: 8080
      targetPort: 80
  selector:
    app: azure-asp-net-web
  type: LoadBalancer

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;※ If you didn’t replace ACR name in yaml file, pod status would be ErrImagePull or ImagePullBackOff. You should replce it.&lt;/p&gt;

&lt;h3 id=&quot;4-deploy-to-aks&quot;&gt;4) Deploy to AKS&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
## create Pod, deployment, and service
kubectl create -f azure-asp-net-web.yaml


## check pod
kubectl get pod

## check service
kubectl get service

## check deployment
kubectl get deployment
  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;5-connect-to-web-page&quot;&gt;5) Connect to web page&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
kubectl get service
## ---Sample of result ---
## NAME                  TYPE           CLUSTER-IP     EXTERNAL-IP     PORT(S)          AGE
## azure-asp-net-lb      LoadBalancer   10.0.169.133   52.186.27.141   8080:31455/TCP   90s
## hello-world-service   LoadBalancer   10.0.69.140    13.92.82.195    80:30213/TCP     3h32m
## kubernetes            ClusterIP      10.0.0.1       ((none))          443/TCP          3h46m

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Type in bowser 52.186.27.141:8080    ( IP address will differ with my result, Type your own address )
&lt;img src=&quot;/assets/images/001.azure-cicd-asp-main.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;additional-kubectl-commands&quot;&gt;Additional kubectl commands&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
## delete deployment
kubectl delete deployment ((deployment name))

## delete service 
kubectl delete service ((service name))


## delete pod
kubectl delete pod ((pod name))


## check details
kubectl describe (service|deployment|pod) (name)
  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;6-continueously-manage-by-jenkins-and-github--see-the-below-reference&quot;&gt;6. Continueously manage by Jenkins and github : See the below reference&lt;/h2&gt;
&lt;p&gt;reference : https://docs.microsoft.com/en-us/azure/aks/jenkins-continuous-deployment&lt;/p&gt;

&lt;hr class=&quot;footnotes-sep&quot; /&gt;

&lt;section class=&quot;footnotes&quot;&gt;
&lt;ol class=&quot;footnotes-list&quot;&gt;
    &lt;li id=&quot;fn1&quot; class=&quot;footnote-item&quot;&gt;
            reference: &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/architecture/example-scenario/apps/devops-with-aks&quot;&gt;
                &lt;small&gt;https://docs.microsoft.com/en-us/azure/architecture/example-scenario/apps/devops-with-aks&lt;/small&gt;
            &lt;/a&gt; 
            &lt;a href=&quot;#fnref1&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn2&quot; class=&quot;footnote-item&quot;&gt;
            reference: &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/role-based-access-control/built-in-roles&quot;&gt;
                &lt;small&gt;https://docs.microsoft.com/en-us/azure/role-based-access-control/built-in-roles&lt;/small&gt;
            &lt;/a&gt; 
            &lt;a href=&quot;#fnref2&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn3&quot; class=&quot;footnote-item&quot;&gt;
            reference: &lt;a href=&quot;https://docs.microsoft.com/ko-kr/azure/jenkins/install-jenkins-solution-template&quot;&gt;
                &lt;small&gt;https://docs.microsoft.com/ko-kr/azure/jenkins/install-jenkins-solution-template&lt;/small&gt;
            &lt;/a&gt; 
            &lt;a href=&quot;#fnref3&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn4&quot; class=&quot;footnote-item&quot;&gt;
            reference: &lt;a href=&quot;https://rudgh1027.github.io/dotnetMVCDeploy&quot;&gt;
                &lt;small&gt;https://rudgh1027.github.io/dotnetMVCDeploy&lt;/small&gt;
            &lt;/a&gt; 
            &lt;a href=&quot;#fnref4&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn5&quot; class=&quot;footnote-item&quot;&gt;
            reference: &lt;a href=&quot; https://docs.microsoft.com/en-us/azure/aks/tutorial-kubernetes-prepare-acr&quot;&gt;
                &lt;small&gt; https://docs.microsoft.com/en-us/azure/aks/tutorial-kubernetes-prepare-acr&lt;/small&gt;
            &lt;/a&gt; 
            &lt;a href=&quot;#fnref5&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn6&quot; class=&quot;footnote-item&quot;&gt;
            reference: &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/aks/tutorial-kubernetes-deploy-cluster#install-the-kubernetes-cli&quot;&gt;
                &lt;small&gt;https://docs.microsoft.com/en-us/azure/aks/tutorial-kubernetes-deploy-cluster#install-the-kubernetes-cli&lt;/small&gt;
            &lt;/a&gt; 
            &lt;a href=&quot;#fnref6&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn7&quot; class=&quot;footnote-item&quot;&gt;
            reference: &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/aks/tutorial-kubernetes-deploy-cluster#connect-to-cluster-using-kubectl&quot;&gt;
                &lt;small&gt;https://docs.microsoft.com/en-us/azure/aks/tutorial-kubernetes-deploy-cluster#connect-to-cluster-using-kubectl&lt;/small&gt;
            &lt;/a&gt; 
            &lt;a href=&quot;#fnref7&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn8&quot; class=&quot;footnote-item&quot;&gt;
            reference: &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/aks/jenkins-continuous-deployment&quot;&gt;
                &lt;small&gt;https://docs.microsoft.com/en-us/azure/aks/jenkins-continuous-deployment&lt;/small&gt;
            &lt;/a&gt; 
            &lt;a href=&quot;#fnref8&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;
    &lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</content>

      
      
      
      
      

      <author>
          <name>gkarchy</name>
        
        
      </author>

      

      
        <category term="devops" />
      
        <category term="azure" />
      

      
        <summary type="html">Describe this pattern [1]</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Queue Based Load Leveling</title>
      <link href="/queueBasedLoadLeveling" rel="alternate" type="text/html" title="Queue Based Load Leveling" />
      <published>2019-10-16T19:18:00+09:00</published>
      <updated>2019-10-16T19:18:00+09:00</updated>
      <id>/queueBasedLoadLeveling</id>
      <content type="html" xml:base="/queueBasedLoadLeveling">&lt;h2 id=&quot;describe-this-pattern-1&quot;&gt;Describe this pattern &lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;

&lt;h3 id=&quot;1-feature&quot;&gt;1. Feature&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Queue evenly transfer messages with certain speed. So that it can prevent service disorder caused by high traffic.&lt;/li&gt;
  &lt;li&gt;We can also check change of scales depending on request.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-advantages&quot;&gt;2. Advantages&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;In case of service disorder, clients could send request due to queue as buffer.&lt;/li&gt;
  &lt;li&gt;scaling up and down number of queues and services. As a result, we could maximize availability.&lt;/li&gt;
  &lt;li&gt;optimizing cost.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-requirement&quot;&gt;3. Requirement&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Need to control message processing speed&lt;/li&gt;
  &lt;li&gt;Asynchronous messaging mechanism is needed&lt;/li&gt;
  &lt;li&gt;It can be degraded because of competition caused by auto scaling.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;use-case&quot;&gt;Use case&lt;/h2&gt;

&lt;h3 id=&quot;1-faced-problem-case-1&quot;&gt;1. Faced Problem (Case 1)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.microsoft.com/ko-kr/azure/architecture/patterns/_images/queue-based-load-leveling-overwhelmed.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Service can fail, if requests from web app to datastore are increased.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-solution-case-2&quot;&gt;2. Solution (Case 2)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.microsoft.com/ko-kr/azure/architecture/patterns/_images/queue-based-load-leveling-function.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;It could control writing speed to datastore using Service bus queue and Function app.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;example&quot;&gt;Example&lt;/h2&gt;
&lt;h3 id=&quot;1-plan&quot;&gt;1. Plan&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Suppose to Health care system that collects body heat and heartbeat in seconds.&lt;/li&gt;
  &lt;li&gt;Use Azure table storage as datastore (Because it has limit of processing transaction so that it will occur disorder)&lt;/li&gt;
  &lt;li&gt;Case 1 : Console application -&amp;gt; Table storage (Several requests are expected to fail, If 100-thousands of job have been requested)&lt;/li&gt;
  &lt;li&gt;Case 2 : Console application -&amp;gt; Service bus queue -&amp;gt; Function app -&amp;gt; Table storage&lt;/li&gt;
  &lt;li&gt;All requests will complete due to queue as buffer.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-practice&quot;&gt;2. Practice&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;It already wrote in github repository. &lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn2&quot; id=&quot;fnref2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;Before inserting data from &lt;strong&gt;service bus queue&lt;/strong&gt; to &lt;strong&gt;Table storage&lt;/strong&gt; using &lt;strong&gt;Azure function app&lt;/strong&gt;, I inserted 6000+ data to &lt;strong&gt;service bus queue&lt;/strong&gt; in advance. (It takes 30 minutes)
&lt;img src=&quot;/assets/images/loadLeveling_queueCount.png&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;And then, running &lt;strong&gt;Azure function app&lt;/strong&gt; to put data into &lt;strong&gt;Table storage&lt;/strong&gt; (It takes only a few seconds)
&lt;img src=&quot;/assets/images/loadLeveling_tableMetric.png&quot; /&gt;
    &lt;h2 id=&quot;lessen--learn&quot;&gt;Lessen &amp;amp; Learn&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Testing on Case 1 : Pass
    &lt;ul&gt;
      &lt;li&gt;Impossible to make enough transaction : Console application can send only one or two messages to queue, but table storage can write 20-thousands of data per 1 second.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;personal perspective
    &lt;ul&gt;
      &lt;li&gt;To predict amount of usage during POC period, this pattern is proper to using(Cost-effective, stable availability)&lt;/li&gt;
      &lt;li&gt;Selecting SaaS product, Based on predictation of usage. (Example of NoSQL type)
        &lt;ul&gt;
          &lt;li&gt;Below 20,000 TPS : Azure table storage (Can be complemented by MQ)&lt;/li&gt;
          &lt;li&gt;Below 10,000,000 TPS : Azure CosmosDB (Can be complemented by MQ)&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn3&quot; id=&quot;fnref3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
          &lt;li&gt;Over 10,000,000 TPS : Azure CosmosDB + Azure cache for Redis &lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn4&quot; id=&quot;fnref4&quot;&gt;[4]&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Recommend Cosmos DB rather than Azure table storage(High TPS, Recovery option … etc)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Additional Example 1 &lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn5&quot; id=&quot;fnref5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.microsoft.com/ko-kr/azure/architecture/reference-architectures/app-service-web-app/images/scalable-web-app.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Requet backgroud process using queue and function, so that it preserves scalablity and availability.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Additional Example 2 &lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn6&quot; id=&quot;fnref5&quot;&gt;[6]&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://docs.microsoft.com/ko-kr/azure/architecture/example-scenario/ai/media/mass-ingestion-newsfeeds-architecture.png&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;passing through several APIs sequentially&lt;/li&gt;
      &lt;li&gt;If certain API faces disorder or bottleneck, Queues take a role as buffer for load leveling.&lt;/li&gt;
      &lt;li&gt;If you complement this system using circuit-breaker and retry pattern, availability and efficiency will be maximized.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr class=&quot;footnotes-sep&quot; /&gt;

&lt;section class=&quot;footnotes&quot;&gt;
&lt;ol class=&quot;footnotes-list&quot;&gt;
    &lt;li id=&quot;fn1&quot; class=&quot;footnote-item&quot;&gt;
            reference: &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/architecture/patterns/queue-based-load-leveling&quot;&gt;
                &lt;small&gt;https://docs.microsoft.com/en-us/azure/architecture/patterns/queue-based-load-leveling&lt;/small&gt;
            &lt;/a&gt; 
            &lt;a href=&quot;#fnref1&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn2&quot; class=&quot;footnote-item&quot;&gt;
            reference: &lt;a href=&quot;https://github.com/rudgh1027/cloud/blob/master/azure/002.queueTriggeredFunction_tableInsert/README.md&quot;&gt;
                &lt;small&gt;https://github.com/rudgh1027/cloud/blob/master/azure/002.queueTriggeredFunction_tableInsert/README.md&lt;/small&gt;
            &lt;/a&gt; 
            &lt;a href=&quot;#fnref2&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn3&quot; class=&quot;footnote-item&quot;&gt;
            reference: &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/cosmos-db/table-support&quot;&gt;
                &lt;small&gt;https://docs.microsoft.com/en-us/azure/cosmos-db/table-support&lt;/small&gt;
            &lt;/a&gt; 
            &lt;a href=&quot;#fnref3&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn4&quot; class=&quot;footnote-item&quot;&gt;
            reference: &lt;a href=&quot;https://azure.microsoft.com/en-us/services/cache/&quot;&gt;
                &lt;small&gt;https://azure.microsoft.com/en-us/services/cache/&lt;/small&gt;
            &lt;/a&gt; 
            &lt;a href=&quot;#fnref4&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn5&quot; class=&quot;footnote-item&quot;&gt;
            reference: &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/architecture/reference-architectures/app-service-web-app/scalable-web-app&quot;&gt;
                &lt;small&gt;https://docs.microsoft.com/en-us/azure/architecture/reference-architectures/app-service-web-app/scalable-web-app&lt;/small&gt;
            &lt;/a&gt; 
            &lt;a href=&quot;#fnref5&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn6&quot; class=&quot;footnote-item&quot;&gt;
            reference: &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/architecture/example-scenario/ai/newsfeed-ingestion&quot;&gt;
                &lt;small&gt;https://docs.microsoft.com/en-us/azure/architecture/example-scenario/ai/newsfeed-ingestion&lt;/small&gt;
            &lt;/a&gt; 
            &lt;a href=&quot;#fnref6&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;
    &lt;/li&gt;
&lt;/ol&gt;


&lt;/section&gt;</content>

      
      
      
      
      

      <author>
          <name>gkarchy</name>
        
        
      </author>

      

      
        <category term="architecture" />
      
        <category term="azure" />
      

      
        <summary type="html">Describe this pattern [1]</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Queue Triggered Azure Function App 2</title>
      <link href="/queue-Triggered-Function_tableInsert" rel="alternate" type="text/html" title="Queue Triggered Azure Function App 2" />
      <published>2019-10-14T19:18:00+09:00</published>
      <updated>2019-10-14T19:18:00+09:00</updated>
      <id>/queue-Triggered-Function_tableInsert</id>
      <content type="html" xml:base="/queue-Triggered-Function_tableInsert">&lt;h2 id=&quot;architecture&quot;&gt;Architecture&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.microsoft.com/ko-kr/azure/architecture/patterns/_images/queue-based-load-leveling-function.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;I'll implements this architecture using &lt;b&gt;azure table storage&lt;/b&gt; as datastore and &lt;b&gt;console application program&lt;/b&gt; as web app.&lt;/p&gt;
&lt;p&gt;I recommand you to follow everything in previous practice. &lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h2 id=&quot;procedure&quot;&gt;Procedure&lt;/h2&gt;
&lt;p&gt;If you complete all procedure in privious practice, comtinue following procedure.&lt;/p&gt;

&lt;h3 id=&quot;1-get-source-from-github&quot;&gt;1. Get source from github&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
git init source           #source can be replaced with other directory name you want
cd source
git remote add -f origin https://github.com/rudgh1027/cloud.git
git config core.sparseCheckout true
echo &quot;azure/002.queueTriggeredFunction_tableInsert/*&quot; &amp;gt;&amp;gt; .git/info/sparse-checkout
git pull origin master
cd azure/002.queueTriggeredFunction_tableInsert/

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2-editting-parameter-name&quot;&gt;2. Editting Parameter Name&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
## complete names of resources
vi exported.dat

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3-deploy-service-bus-queue-and-azure-function-app&quot;&gt;3. Deploy Service Bus Queue and Azure Function App&lt;/h3&gt;
&lt;p&gt;Just run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
## deploy queue
./deployq.sh
## deploy function app
./deployFunc.sh

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;4-make-project&quot;&gt;4. Make Project&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
./makeProj.sh
## Select a worker runtime:
## 1. dotnet
## 2. node
## 3. python
## 4. powershell (preview)
## Choose option: 1            Select 1

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;5-deploy-table-storage&quot;&gt;5. Deploy Table Storage&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;
az storage table create --name {yourTableStorageName} --account-name {yourStorageAccountName}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can reuse storage account already created in previous practice.&lt;/p&gt;

&lt;p&gt;Determine your table storage name and replace {yourTableStorageName} with that.&lt;/p&gt;

&lt;p&gt;output&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
{
  &quot;created&quot;: true
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;6-editting-functionappnamecs-source---2&quot;&gt;6. Editting {FunctionAppName}.cs Source   &lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn2&quot; id=&quot;fnref2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;

&lt;p&gt;Open ~/source/azure/002.queueTriggeredFunction_tableInsert/(projectname).cs&lt;/p&gt;
&lt;p&gt;Now our codes are&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
using System;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Host;
using Microsoft.Extensions.Logging;

namespace funcgkim0012
{
    public static class funcgkim0012
    {
        [FunctionName(&quot;funcgkim0012&quot;)]
        public static void Run([ServiceBusTrigger(&quot;yourqueuename&quot;, Connection = &quot;MyServiceBusConnection&quot;)]string myQueueItem, ILogger log)
        {
            log.LogInformation($&quot;C# ServiceBus queue trigger function processed message: {myQueueItem}&quot;);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should add some codes like this.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
using System;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Host;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using Microsoft.Azure.WebJobs.Extensions.Storage;

namespace funcgkim0012
{
    public class MyHealthData
    {
        public string PartitionKey { get; set; }
        public string RowKey { get; set; }
        public int heat { get; set; }
        public int heartbaet { get; set; }
    }
    public static class funcgkim0012
    {
        [FunctionName(&quot;funcgkim0012&quot;)]
        [return: Table(&quot;gkHealthCareData&quot;)]
        public static MyHealthData Run([ServiceBusTrigger(&quot;q-gkim-02&quot;, Connection = &quot;MyServiceBusConnection&quot;)]string myQueueItem, ILogger log)
        {
            MyHealthData md = JsonConvert.DeserializeObject&amp;lt;MyHealthData&amp;gt;(myQueueItem);
            log.LogInformation($&quot;C# ServiceBus queue trigger function processed message: {myQueueItem}&quot;);
            return md;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;7-import-nuget-package&quot;&gt;7. Import Nuget Package&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
## In your azure cloud shell, cd ..../{yourfunctionapp}/
## Import package of webjobs storage extension
dotnet add package Microsoft.Azure.WebJobs.Extensions.Storage --version 3.0.4
## Import package of Json
dotnet add package Newtonsoft.Json --version 11.0.2

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;8-local-build&quot;&gt;8. Local Build&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
## bash
func start --build

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If error occur saying&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
[10/8/19 8:44:12 AM] A host error has occurred
[10/8/19 8:44:12 AM] System.Private.CoreLib: Could not load file or assembly 'Microsoft.Azure.WebJobs.Extensions.Storage, Version=3.0.8.0, Culture=neutral, PublicKeyToken=.........'. Could not find or load a specific file. (Exception from HRESULT: 0x80131621). System.Private.CoreLib: Could not load file or assembly 'Microsoft.Azure.WebJobs.Extensions.Storage, Version=3.0.8.0, Culture=neutral, PublicKeyToken=........'.
[10/8/19 8:44:12 AM] Stopping JobHost
Value cannot be null.
Parameter name: provider
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then you have to use other extension version of azuer Storage. This error was occured because visual studio code and package version didn't match.&lt;/p&gt;
&lt;p&gt;I recommand 3.0.4 version of &lt;b&gt;Microsoft.Azure.WebJobs.Extensions.Storage&lt;/b&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-test-1&quot;&gt;1) Test 1&lt;/h4&gt;
&lt;p&gt;Open another tab at your browser and open additional terminal in azure. And then type..&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd ~/source/azure/001.queueTriggeredFunction/sender/&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Open Program.cs&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
...
      static string ServiceBusConnectionString=&quot;....&quot;;
      static string QueueName=&quot;...&quot;; 
...

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Insert your queue name and connectionString.
Save and run “dotnet run”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
## bash
dotnet run

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In your terminal running azure function app project, you can see a message log.&lt;/p&gt;

&lt;h3 id=&quot;9-deploy-to-azure-function&quot;&gt;9. Deploy To Azure Function&lt;/h3&gt;
&lt;p&gt;Go to “~/source/azure/001.queueTriggeredFunction/{FunctionAppName}”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
## bash
func azure functionapp publish {FunctionAppName}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;1-test-2&quot;&gt;1) Test 2&lt;/h4&gt;
&lt;p&gt;Go to “~/source/azure/001.queueTriggeredFunction/sender/”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
## bash
dotnet run

&lt;/code&gt;&lt;/pre&gt;

&lt;hr class=&quot;footnotes-sep&quot; /&gt;

&lt;section class=&quot;footnotes&quot;&gt;
&lt;ol class=&quot;footnotes-list&quot;&gt;
    &lt;li id=&quot;fn1&quot; class=&quot;footnote-item&quot;&gt;
            reference: &lt;a href=&quot;https://rudgh1027.github.io/queue-Triggered-Function&quot;&gt;
                &lt;small&gt;https://rudgh1027.github.io/queue-Triggered-Function&lt;/small&gt;
            &lt;/a&gt; 
            &lt;a href=&quot;#fnref1&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn2&quot; class=&quot;footnote-item&quot;&gt;
            reference: &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-table#input---c-example---one-entity&quot;&gt;
                &lt;small&gt;https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-table#input---c-example---one-entity&lt;/small&gt;
            &lt;/a&gt; 
            &lt;a href=&quot;#fnref2&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;
    &lt;/li&gt;
&lt;/ol&gt;

&lt;/section&gt;</content>

      
      
      
      
      

      <author>
          <name>gkarchy</name>
        
        
      </author>

      

      
        <category term="cloud" />
      
        <category term="azure" />
      

      
        <summary type="html">Architecture I'll implements this architecture using azure table storage as datastore and console application program as web app. I recommand you to follow everything in previous practice. [1]</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Queue Triggered Azure Function App 1</title>
      <link href="/queue-Triggered-Function" rel="alternate" type="text/html" title="Queue Triggered Azure Function App 1" />
      <published>2019-10-09T19:18:00+09:00</published>
      <updated>2019-10-09T19:18:00+09:00</updated>
      <id>/queue-Triggered-Function</id>
      <content type="html" xml:base="/queue-Triggered-Function">&lt;h2 id=&quot;architecture&quot;&gt;Architecture&lt;/h2&gt;
&lt;p&gt;&lt;img style=&quot;width: 700px;&quot; src=&quot;https://docs.microsoft.com/ko-kr/azure/architecture/patterns/_images/queue-based-load-leveling-pattern.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We are going to make &lt;b&gt;dotnet console application as task&lt;/b&gt;, &lt;b&gt;azure function app as service&lt;/b&gt;.&lt;/p&gt;

&lt;h2 id=&quot;procedure&quot;&gt;Procedure&lt;/h2&gt;
&lt;p&gt;This pratice is optimized for &lt;b&gt;bash shell and azure cli in Azure Cloud Shell.&lt;/b&gt; Go to azure portal and run azure cloud shell&lt;/p&gt;

&lt;h3 id=&quot;1-get-source-from-github&quot;&gt;1. Get source from github&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
git init {source}           #{source} can be replaced with other directory name you want
cd source
git remote add -f origin https://github.com/rudgh1027/cloud.git
git config core.sparseCheckout true
echo &quot;azure/001.queueTriggeredFunction/*&quot; &amp;gt;&amp;gt; .git/info/sparse-checkout
git pull origin master
cd azure/001.queueTriggeredFunction/

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2-editting-parameter-name&quot;&gt;2. Editting Parameter Name&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
## complete names of resources
vi exported.dat

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3-deploy-service-bus-queue-and-azure-function-app&quot;&gt;3. Deploy Service Bus Queue and Azure Function App&lt;/h3&gt;
&lt;p&gt;Just run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
## deploy queue
./deployq.sh
## deploy function app
./deployFunc.sh

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;4-make-project&quot;&gt;4. Make Project&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
./makeProj.sh
## Select a worker runtime:
## 1. dotnet
## 2. node
## 3. python
## 4. powershell (preview)
## Choose option: 1            Select 1

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;5-editting-functionappnamecs-source&quot;&gt;5. Editting {FunctionAppName}.cs Source&lt;/h3&gt;
&lt;p&gt;Now we can see Visual Studio code edittor.
Open ~/source/azure/001.queueTriggeredFunction/(projectname).cs&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
using System;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Host;
using Microsoft.Extensions.Logging;

namespace funcgkim0012
{
    public static class funcgkim0012
    {
        [FunctionName(&quot;funcgkim0012&quot;)]
        public static void Run([ServiceBusTrigger(&quot;myqueue&quot;, Connection = &quot;&quot;)]string myQueueItem, ILogger log)
        {
            log.LogInformation($&quot;C# ServiceBus queue trigger function processed message: {myQueueItem}&quot;);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Replace myqueue with your queue name in your sesrvice bus namespace.
In my code, I already define connectionString name, &lt;b&gt;MyServiceBusConnection&lt;/b&gt;.
So replace &quot;&quot; with &quot;MyServiceBusConnection&quot;.&lt;/p&gt;
&lt;p&gt;Now our code is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
using System;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Host;
using Microsoft.Extensions.Logging;
using Microsoft.Azure.WebJobs.Extensions.Storage;

namespace funcgkim0012
{
    public static class funcgkim0012
    {
        [FunctionName(&quot;funcgkim0012&quot;)]
        public static void Run([ServiceBusTrigger(&quot;yourqueuename&quot;, Connection = &quot;MyServiceBusConnection&quot;)]string myQueueItem, ILogger log)
        {
            log.LogInformation($&quot;C# ServiceBus queue trigger function processed message: {myQueueItem}&quot;);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;6-import-nuget-package&quot;&gt;6. Import Nuget Package&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
## In your azure cloud shell, cd ..../{yourfunctionapp}/
## Import package of webjobs storage extension
dotnet add package Microsoft.Azure.WebJobs.Extensions.Storage --version 3.0.4

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;7-local-build&quot;&gt;7. Local Build&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
## bash
func start --build

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;1-test_1&quot;&gt;1) Test_1&lt;/h4&gt;
&lt;p&gt;Go to “~/source/azure/001.queueTriggeredFunction/sender/”&lt;/p&gt;
&lt;p&gt;Open Program.cs and insert your queue name and connectionString.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
...
      static string ServiceBusConnectionString=&quot;....&quot;;
      static string QueueName=&quot;...&quot;; 
...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save and run “dotnet run”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
## bash
dotnet run

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In your terminal running azure function app project, you can see a message log.&lt;/p&gt;

&lt;h3 id=&quot;8-deploy-to-azure-function&quot;&gt;8. Deploy To Azure Function&lt;/h3&gt;
&lt;p&gt;Go to “~/source/azure/001.queueTriggeredFunction/{FunctionAppName}”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
## bash
func azure functionapp publish {FunctionAppName}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;1-test_2&quot;&gt;1) Test_2&lt;/h4&gt;
&lt;p&gt;Go to “~/source/azure/001.queueTriggeredFunction/sender/”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
## bash
dotnet run

&lt;/code&gt;&lt;/pre&gt;</content>

      
      
      
      
      

      <author>
          <name>gkarchy</name>
        
        
      </author>

      

      
        <category term="cloud" />
      
        <category term="azure" />
      

      
        <summary type="html">Architecture We are going to make dotnet console application as task, azure function app as service.</summary>
      

      
      
    </entry>
  
</feed>
